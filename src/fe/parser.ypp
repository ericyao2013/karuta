// -*- C++ -*-
%{
#include "sym.h"
#include "fe/builder.h"
#include "fe/emitter.h"
#include "fe/enum_decl.h"
#include "fe/expr.h"
#include "fe/nodecode.h"
#include "fe/stmt.h"
#include "fe/var_decl.h"
#include "synth/resource_params.h"

extern int yylex();
extern void yyerror(const char *msg);

%}
%union {
  class ArrayInitializer *array;
  class Expr *expr;
  class EnumDecl *enum_decl;
  class Stmt *stmt;
  class VarDecl *var_decl;
  class VarDeclSet *var_decl_set;
  class NstBlock *block;
  const char *str;
  sym_t sym;
  uint64_t num;
  struct WidthSpec width_spec;
  class ResourceParamValue *import_param;
  class ResourceParamValueSet *import_params;
}

%type <expr> EXPR ARG_LIST VAR FUNCALL FUNCALL_HEAD
%type <num> ARRAY_SPEC EMPTY_OR_ARRAY_SPEC
%type <var_decl> MODIFIED_VAR VAR_DECL
%type <var_decl_set> VAR_DECL_STMT
%type <array> ARRAY_INITIALIZER ARRAY_ELM_LIST
%type <block> BLOCK IF_STMT FOR_STMT
%type <block> WHILE_STMT DO_WHILE_STMT SWITCH_STMT
%type <stmt> IF_COND_PART IF_WITH_ELSE
%type <stmt> FOR_COND_PART WHILE_COND_PART
%type <stmt> DO_WHILE_HEAD DO_WHILE_BODY
%type <var_decl_set> ARG_DECL ARG_DECL_LIST
%type <var_decl> RETURN_TYPE
%type <var_decl_set> RETURN_SPEC RETURN_TYPE_LIST
%type <enum_decl> ENUM_DECL ENUM_ITEM_LIST
%type <stmt> STRUCT_DECL STRUCT_ELEMENT_LIST
%type <str> STR
%type <sym> SYM TYPE_NAME
%type <num> NUM ARRAY_ELM
%type <num> K_ASSIGN K_LG_COMPARE K_EQ_COMPARE K_BIT_CONCAT
%type <num> K_ADD_SUB K_INC_DEC K_SHIFT
%type <num> K_LOGIC_AND K_LOGIC_OR
%type <width_spec> WIDTH_SPEC
%type <import_param> IMPORT_PARAM IMPORT_PARAM_HEAD
%type <import_params> IMPORT_PARAM_LIST

%token K_DEF K_FUNC K_ENUM K_IMPORT K_STRUCT
%token K_ASSIGN K_SHIFT
%token K_INT K_BOOL K_STRING K_OBJECT K_THREAD K_CHANNEL K_MAILBOX
%token K_ADD_SUB K_LG_COMPARE K_EQ_COMPARE
%token K_INC_DEC K_CONST
%token K_IF K_ELSE K_RETURN K_GOTO K_FOR K_SPAWN
%token K_WHILE K_DO K_CONTINUE
%token K_SWITCH K_CASE K_DEFAULT K_BREAK

%token NUM
%token SYM
%token STR

/* precedence definitions */
%left K_IF
%left ','
%right K_ASSIGN
%right '?' ':'
%left K_LOGIC_OR
%left K_LOGIC_AND
%left K_BIT_CONCAT
%left '|'
%left '^'
%left '&'
%left K_EQ_COMPARE
%left K_LG_COMPARE
%left K_SHIFT
%left K_ADD_SUB
%left '*'
%right '!' '~' SIGN K_INC_DEC ADDRESS
%left '.' '[' ']'

%%
input : {
} | input FUNC_DECL {
} | input STMT {
}

IMPORT_PARAM_HEAD : SYM K_ASSIGN '(' STR {
  $$ = synth::Importer::BuildStrParam($1, $4);
} | IMPORT_PARAM_HEAD ',' STR {
  synth::Importer::AddStrParam($1, $3);
  $$ = $1;
}

IMPORT_PARAM : SYM K_ASSIGN STR {
  $$ = synth::Importer::BuildStrParam($1, $3);
} | IMPORT_PARAM_HEAD ')' {
  $$ = $1;
}

IMPORT_PARAM_LIST : IMPORT_PARAM {
  $$ = synth::Importer::BuildParamSet(nullptr, $1);
} | IMPORT_PARAM_LIST ',' IMPORT_PARAM {
  $$ = synth::Importer::BuildParamSet($1, $3);
}

IMPORT_SPEC : {
  Emitter::SetImportedResource(nullptr);
} | '@' SYM '(' IMPORT_PARAM_LIST ')' {
  Emitter::SetImportedResource($4);
}

RETURN_TYPE : TYPE_NAME WIDTH_SPEC {
  $$ = Builder::ReturnType($1, $2.width, $2.name);
}

RETURN_TYPE_LIST : RETURN_TYPE {
 $$ = Builder::ReturnDeclList(nullptr, $1);
} | RETURN_TYPE_LIST ',' RETURN_TYPE {
 $$ = Builder::ReturnDeclList($1, $3);
}

RETURN_SPEC : {
  $$ = Builder::ReturnDeclList(nullptr, nullptr);
} | '(' RETURN_TYPE_LIST ')' {
  $$ = $2;
}

FUNC_DECL : IMPORT_SPEC FUNC_DECL_HEAD '{' STMT_LIST '}' {
  Emitter::EndFunction();
}

FUNC_DECL_HEAD : FUNC_DECL_NAME ARG_DECL ')' RETURN_SPEC {
  Emitter::SetCurrentFunctionParams();
  Emitter::SetCurrentFunctionArgs($2);
  Emitter::SetCurrentFunctionReturns($4);
}

// K_DEF is for compatibility.
FUNC_DECL_HEAD : K_DEF | K_FUNC

FUNC_DECL_NAME : FUNC_DECL_HEAD VAR '(' {
  Emitter::BeginFunction($2);
}

STMT_LIST : {
} | STMT_LIST STMT {
}

MODIFIED_VAR : VAR {
  $$ = Builder::ModifiedVar($1, false, nullptr);
} | '*' VAR {
  $$ = Builder::ModifiedVar($2, true, nullptr);
} | '*' SYM VAR {
  $$ = Builder::ModifiedVar($3, true, $2);
}

VAR_DECL : TYPE_NAME WIDTH_SPEC MODIFIED_VAR {
  $$ = Builder::BuildVarDecl($1, $2.width, $2.name, $3);
} | K_ENUM TYPE_NAME MODIFIED_VAR {
} | ENUM_DECL MODIFIED_VAR {
}

WIDTH_SPEC : {
  $$ = WidthSpec::Int(numeric::Width::MakeInt(false, 32, 0));
} | '#' NUM {
  $$ = WidthSpec::Int(numeric::Width::MakeInt(false, $2, 0));
} | '#' NUM ':' NUM {
  $$ = WidthSpec::Int(numeric::Width::MakeInt(false, $2, $4));
} | '#' SYM {
  $$ = WidthSpec::Name($2);
} | '#' '#' {
  $$ = WidthSpec::Int(numeric::Width::Null());
}

ARG_DECL : {
  /* no arguments */
  $$ = nullptr;
} | ARG_DECL_LIST {
  $$ = $1;
}

ARG_DECL_LIST : VAR_DECL {
  $$ = Builder::ArgDeclList(nullptr, $1);
} | ARG_DECL_LIST ',' VAR_DECL {
  $$ = Builder::ArgDeclList($1, $3);
} | ARG_DECL_LIST ',' MODIFIED_VAR {
  /* un-typed argument */
  $$ = nullptr;
}

ARRAY_SPEC : '[' ']' {
  $$ = 0;
} | '[' NUM ']' {
  $$ = $2;
}

EMPTY_OR_ARRAY_SPEC : {
  $$ = -1;
} | ARRAY_SPEC {
  $$ = $1;
}

ARRAY_ELM : NUM {
  $$ = $1;
}

ARRAY_ELM_LIST : ARRAY_ELM {
  ArrayInitializer *array = new ArrayInitializer;
  array->num_.push_back($1);
  $$ = array;
} | ARRAY_ELM_LIST ',' ARRAY_ELM {
  $1->num_.push_back($3);
  $$ = $1;
}

ARRAY_INITIALIZER : '{' ARRAY_ELM_LIST '}' {
  $$ = $2;
}

VAR_DECL_STMT : VAR_DECL EMPTY_OR_ARRAY_SPEC {
  Builder::SetArrayLength($1, $2);
  $$ = Builder::VarDeclList(nullptr, $1);
} | VAR_DECL K_ASSIGN EXPR {
  $1->initial_val = $3;
  $$ = Builder::VarDeclList(nullptr, $1);
} | VAR_DECL ARRAY_SPEC K_ASSIGN ARRAY_INITIALIZER {
  Builder::SetArrayLength($1, $2);
  Builder::SetArrayInitializer($1, $4);
  $$ = Builder::VarDeclList(nullptr, $1);
} | VAR_DECL_STMT ',' MODIFIED_VAR {
  sym_t type = Builder::TypeNameFromVarDeclSet($1);
  WidthSpec w = Builder::GetWidthSpecFromVarDeclSet($1);
  $$ = Builder::VarDeclList($1, Builder::BuildVarDecl(type, w.width, w.name, $3));
} | VAR_DECL_STMT ',' MODIFIED_VAR K_ASSIGN EXPR {
  $$ = Builder::VarDeclList($1, $3);
}

TYPE_NAME : K_INT {
  $$ = sym_int;
} | K_BOOL {
  $$ = sym_bool;
} | K_OBJECT {
  $$ = sym_object;
} | K_STRING {
  $$ = sym_string;
}


LABEL : SYM ':' {
}

STMT : ';' {
  /* empty stmt */
} | EXPR ';' {
  Emitter::EmitExprStmt($1);
} | ENUM_DECL ';' {
} | STRUCT_DECL ';' {
} | K_GOTO FUNCALL ';' {
} | K_GOTO SYM ';' {
} | K_RETURN EXPR ';' {
  Emitter::EmitReturnStmt($2);
} | K_RETURN ';' {
  Emitter::EmitReturnStmt(nullptr);
} | BLOCK {
} | IF_STMT {
} | FOR_STMT {
} | WHILE_STMT {
} | DO_WHILE_STMT {
} | SWITCH_STMT {
} | VAR_DECL_STMT ';' {
  Emitter::EmitVarDeclStmtSet($1);
} | LABEL
  | K_IMPORT STR ';' {
  Emitter::EmitImportStmt($2);
} | K_SPAWN FUNCALL ';' {
  Emitter::EmitSpawnStmt($2);
} | THREAD_DECL_STMT ';' {
} | CHANNEL_DECL_STMT ';' {
} | MAILBOX_DECL_STMT ';' {
}

THREAD_DECL_STMT : K_THREAD VAR K_ASSIGN FUNCALL {
  Emitter::EmitThreadDeclStmt($2, $4);
}

CHANNEL_DECL_STMT : K_CHANNEL VAR K_ASSIGN TYPE_NAME WIDTH_SPEC {
  Emitter::EmitChannelDeclStmt($2, $4, $5.width, $5.name);
}

MAILBOX_DECL_STMT : K_MAILBOX VAR K_ASSIGN TYPE_NAME WIDTH_SPEC {
  Emitter::EmitMailboxDeclStmt($2, $4, $5.width, $5.name);
}

IF_COND_PART : K_IF '(' EXPR ')' {
  $$ = Emitter::EmitIfStmt($3);
  Emitter::EmitLabel($$->label_t_);
}

IF_WITH_ELSE : IF_COND_PART BLOCK K_ELSE {
  $$ = $1;
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
}

IF_STMT : IF_COND_PART BLOCK {
  $$ = nullptr;
  Emitter::EmitLabel($1->label_f_);
  Emitter::EmitLabel($1->label_join_);
} | IF_WITH_ELSE BLOCK {
  $$ = nullptr;
  Emitter::EmitLabel($1->label_join_);
} | IF_WITH_ELSE IF_STMT {
  $$ = nullptr;
  Emitter::EmitLabel($1->label_join_);
}

FOR_HEAD : K_FOR '(' EXPR ';' {
  Emitter::BeginBlock();
  Emitter::EmitExprStmt($3);
}

FOR_COND_PART : FOR_HEAD EXPR {
  $$ = Emitter::EmitForStmt($2);
  Emitter::EmitLabel($$->label_t_);
}

FOR_STMT : FOR_COND_PART ';' EXPR ')' BLOCK {
  // join:
  // cond_expr
  // if (cond_expr)
  //  t:
  //  block
  //  repeat_expr
  // goto join:
  //  f:
  Emitter::EmitExprStmt($3);
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
  Emitter::EndBlock();
}

WHILE_COND_PART : K_WHILE '(' EXPR ')' {
  Emitter::BeginBlock();
  // Emit a dummy insn before label_join so that compiler can
  // find a insn after the label.
  Emitter::EmitNop();
  $$ = Emitter::EmitWhileStmt($3);
  Emitter::EmitLabel($$->label_t_);
}

WHILE_STMT : WHILE_COND_PART BLOCK {
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
  Emitter::EndBlock();
}

DO_WHILE_HEAD : K_DO {
  Emitter::BeginBlock();
  Emitter::EmitNop();
  $$ = Builder::DoWhileStmt();
  Emitter::EmitLabel($$->label_join_);
}

DO_WHILE_BODY : DO_WHILE_HEAD BLOCK {
  $$ = $1;
}

DO_WHILE_STMT : DO_WHILE_BODY K_WHILE '(' EXPR ')' {
  Emitter::EmitDoWhileStmt($1, $4);
  Emitter::EmitLabel($1->label_t_);
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
  Emitter::EndBlock();
}

SWITCH_STMT : K_SWITCH '(' EXPR ')' CASES_LIST {
}

CASES_LIST : CASE {
} | CASES_LIST CASE {
}

CASE : K_DEFAULT {
}

BLOCK : BLOCK_HEAD STMT_LIST '}' {
  Emitter::EndBlock();
}

BLOCK_HEAD : '{' {
  /* open new bindings */
  Emitter::BeginBlock();
}

ENUM_DECL : K_ENUM VAR '{' ENUM_ITEM_LIST '}' {
  Emitter::EmitEnumTypeDeclStmt($2, $4);
}

ENUM_ITEM_LIST : SYM {
  $$ = Builder::EnumItemList(nullptr, $1);
} | ENUM_ITEM_LIST ',' SYM {
  $$ = Builder::EnumItemList($1, $3);
}

STRUCT_DECL : STRUCT_DECL_HEAD '{' STRUCT_ELEMENT_LIST '}' {
}

STRUCT_DECL_HEAD : K_STRUCT '{' {
}

STRUCT_ELEMENT_LIST : VAR_DECL_STMT ';' {
} | STRUCT_ELEMENT_LIST VAR_DECL_STMT ';' {
}

EXPR : SYM {
  $$ = Builder::SymExpr($1);
} | '(' EXPR ')' {
  $$ = $2;
} | EXPR '[' EXPR ']' {
  $$ = Builder::ArrayRefExpr($1, $3);
} | EXPR '[' EXPR ':' EXPR ']' {
  $$ = Builder::BitRangeRefExpr($1, $3, $5);
} | EXPR ',' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_COMMA);
} | EXPR '.' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_ELM_REF);
} | FUNCALL {
  $$ = $1;
} | '!' EXPR {
  $$ = Builder::LogicInvertExpr($2);
} | '~' EXPR {
  $$ = Builder::BitInvertExpr($2);
} | '*' EXPR {
  $$ = Builder::RefExpr($2);
} | EXPR K_ADD_SUB EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR '*' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_MUL);
} | EXPR K_SHIFT EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_ASSIGN EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_LG_COMPARE EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_EQ_COMPARE EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_BIT_CONCAT EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_CONCAT);
} | EXPR '&' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_AND);
} | EXPR '|' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_OR);
} | EXPR '^' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_XOR);
} | EXPR K_LOGIC_OR EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_LOR);
} | EXPR K_LOGIC_AND EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_LAND);
} | EXPR K_INC_DEC {
  $$ = Builder::IncDecExpr($1, $2, true);
} | K_INC_DEC EXPR {
  $$ = Builder::IncDecExpr($2, $1, false);
} | K_ADD_SUB EXPR %prec SIGN {
  $$ = Builder::SignedExpr($1, $2);
} | EXPR '?' EXPR ':' EXPR {
  $$ = Builder::TriTerm($1, $3, $5);
} | STR {
  $$ = Builder::StrExpr($1);
} | NUM {
  $$ = Builder::NumExpr($1);
}

VAR : SYM {
  $$ = Builder::SymExpr($1);
} | VAR '.' SYM {
  $$ = Builder::ElmSymRefExpr($1, $3);
}

FUNCALL_HEAD : SYM '(' {
  $$ = Builder::SymExpr($1);
}

FUNCALL :  FUNCALL_HEAD ARG_LIST ')' {
  $$ = Builder::FuncallExpr($1, $2);
}

ARG_LIST : {
  $$ = nullptr;
} | EXPR {
  $$ = $1;
}

%%
