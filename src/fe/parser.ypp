// -*- C++ -*-
%{
#include "base/annotation_builder.h"
#include "base/status.h"
#include "base/sym.h"
#include "fe/builder.h"
#include "fe/emitter.h"
#include "fe/enum_decl.h"
#include "fe/expr.h"
#include "fe/nodecode.h"
#include "fe/scanner.h"
#include "fe/stmt.h"
#include "fe/var_decl.h"

extern int yylex();
extern void yyerror(const char *msg);

%}
%union {
  class ArrayInitializer *array;
  class Expr *expr;
  class ExprSet *expr_set;
  class EnumDecl *enum_decl;
  class Stmt *stmt;
  class VarDecl *var_decl;
  class VarDeclSet *var_decl_set;
  class NstBlock *block;
  const char *str;
  sym_t sym;
  NumericLiteral num;
  int sub_op;
  struct WidthSpec width_spec;
  class Annotation *annotation;
  class AnnotationValue *annotation_value;
  class AnnotationValueSet *annotation_value_set;
}

%type <expr> EXPR ARG_LIST VAR FUNCALL FUNCALL_HEAD
%type <expr_set> VAR_LIST
%type <num> ARRAY_SPEC EMPTY_OR_ARRAY_SPEC
%type <var_decl_set> VAR_DECL_STMT VAR_DECL VAR_DECL_TAIL
%type <array> ARRAY_INITIALIZER ARRAY_ELM_LIST
%type <block> BLOCK IF_STMT FOR_STMT
%type <block> WHILE_STMT DO_WHILE_STMT SWITCH_STMT
%type <stmt> IF_COND_PART IF_WITH_ELSE
%type <stmt> FOR_COND_PART WHILE_COND_PART
%type <stmt> DO_WHILE_HEAD DO_WHILE_BODY
%type <var_decl_set> ARG_DECL ARG_DECL_LIST
%type <var_decl> RETURN_TYPE
%type <var_decl_set> RETURN_SPEC RETURN_TYPE_LIST
%type <enum_decl> ENUM_DECL ENUM_ITEM_LIST
%type <str> STR
%type <sym> SYM TYPE_NAME
%type <num> NUM ARRAY_ELM K_BIT_CONCAT
%type <sub_op> K_ASSIGN K_LG_COMPARE K_EQ_COMPARE
%type <sub_op> K_ADD_SUB K_INC_DEC K_SHIFT
%type <num> K_LOGIC_AND K_LOGIC_OR
%type <width_spec> WIDTH_SPEC
%type <annotation> ANNOTATION_OR_EMPTY
%type <annotation_value> ANNOTATION_VALUE IMPORT_PARAM_HEAD
%type <annotation_value_set> ANNOTATION_VALUE_LIST

%token K_DEF K_FUNC K_ENUM K_IMPORT
%token K_ASSIGN K_SHIFT
%token K_INT K_BOOL K_STRING K_OBJECT K_THREAD K_CHANNEL K_MAILBOX K_VAR
%token K_ADD_SUB K_LG_COMPARE K_EQ_COMPARE
%token K_INC_DEC K_CONST
%token K_IF K_ELSE K_RETURN K_GOTO K_FOR K_SPAWN
%token K_WHILE K_DO K_CONTINUE
%token K_SWITCH K_CASE K_DEFAULT K_BREAK

%token NUM
%token SYM
%token STR

/* precedence definitions */
%left K_IF
%left ','
%right K_ASSIGN
%right '?' ':'
%left K_LOGIC_OR
%left K_LOGIC_AND
%left K_BIT_CONCAT
%left '|'
%left '^'
%left '&'
%left K_EQ_COMPARE
%left K_LG_COMPARE
%left K_SHIFT
%left K_ADD_SUB
%left '*'
%right '!' '~' SIGN K_INC_DEC ADDRESS
%left '.' '[' ']'

%%
input : {
} | input FUNC_DECL {
} | input STMT {
}

IMPORT_PARAM_HEAD : SYM K_ASSIGN '(' STR {
  $$ = AnnotationBuilder::BuildStrParam($1, $4);
} | IMPORT_PARAM_HEAD ',' STR {
  AnnotationBuilder::AddStrParam($1, $3);
  $$ = $1;
}

ANNOTATION_VALUE : SYM K_ASSIGN STR {
  $$ = AnnotationBuilder::BuildStrParam($1, $3);
} | IMPORT_PARAM_HEAD ')' {
  $$ = $1;
}

ANNOTATION_VALUE_LIST : {
  $$ = AnnotationBuilder::BuildParamSet(nullptr, nullptr);
} | ANNOTATION_VALUE {
  $$ = AnnotationBuilder::BuildParamSet(nullptr, $1);
} | ANNOTATION_VALUE_LIST ',' ANNOTATION_VALUE {
  $$ = AnnotationBuilder::BuildParamSet($1, $3);
}

ANNOTATION_OR_EMPTY : {
  $$ = Emitter::SetAnnotation(sym_null, nullptr);
} | '@' SYM '(' ANNOTATION_VALUE_LIST ')' {
  $$ = Emitter::SetAnnotation($2, $4);
}

RETURN_TYPE : WIDTH_SPEC {
  $$ = Builder::ReturnType($1.is_primitive, $1.name, $1.width);
}

RETURN_TYPE_LIST : RETURN_TYPE {
 $$ = Builder::ReturnDeclList(nullptr, $1);
} | RETURN_TYPE_LIST ',' RETURN_TYPE {
 $$ = Builder::ReturnDeclList($1, $3);
}

RETURN_SPEC : {
  $$ = Builder::ReturnDeclList(nullptr, nullptr);
} | '(' RETURN_TYPE_LIST ')' {
  $$ = $2;
}

FUNC_DECL : ANNOTATION_OR_EMPTY {Emitter::SetCurrentFunctionAnnotation($1);} FUNC_DECL_HEAD '{' STMT_LIST '}' {
  Emitter::EndFunction();
}

FUNC_DECL_HEAD : FUNC_DECL_NAME ARG_DECL ')' RETURN_SPEC {
  Emitter::SetCurrentFunctionParams();
  Emitter::SetCurrentFunctionArgs($2);
  Emitter::SetCurrentFunctionReturns($4);
}

// K_DEF is for compatibility.
FUNC_DECL_HEAD : K_DEF | K_FUNC

FUNC_DECL_NAME : FUNC_DECL_HEAD VAR '(' {
  Emitter::BeginFunction($2);
}

STMT_LIST : {
} | STMT_LIST STMT {
}

VAR_DECL_TAIL : VAR_LIST WIDTH_SPEC EMPTY_OR_ARRAY_SPEC {
  VarDeclSet *vds = nullptr;
  for (Expr *var : $1->exprs) {
    VarDecl *vd = Builder::BuildVarDecl(var,
					$2.is_primitive, $2.is_ptr, $2.name,
					$2.width);
    Builder::SetArrayLength(vd, $3.value);
    vds = Builder::VarDeclList(vds, vd);
  }
  $$ = vds;
}

VAR_DECL : ANNOTATION_OR_EMPTY {ScannerInterface::InSemiColonStatement();} K_VAR VAR_DECL_TAIL {
  for (VarDecl *vd : $4->decls) {
    Builder::SetVarDeclAnnotation(vd, $1);
  }
  $$ = $4;
} | K_ENUM TYPE_NAME VAR {
} | ENUM_DECL VAR {
}

WIDTH_SPEC : TYPE_NAME {
  $$ = WidthSpec::Name($1, true, false);
} | '#' NUM {
  $$ = WidthSpec::Int(false, $2.value, false);
} | '#' SYM {
  $$ = WidthSpec::Name($2, false, false);
} | '*' WIDTH_SPEC {
  $$.is_ptr = true;
}

ARG_DECL : {
  /* no arguments */
  $$ = nullptr;
} | ARG_DECL_LIST {
  $$ = $1;
}

ARG_DECL_LIST : VAR_DECL_TAIL {
  VarDeclSet *vds = nullptr;
  for (VarDecl *vd : $1->decls) {
    vds = Builder::ArgDeclList(vds, vd);
  }
  if ($1->decls[0]->GetArrayLength() >= 0) {
    yyerror("Array can't be passed to a method");
    YYABORT;
  }
  $$ = vds;
} | ARG_DECL_LIST ',' VAR_DECL_TAIL {
  VarDeclSet *vds = $1;
  for (VarDecl *vd : $3->decls) {
    vds = Builder::ArgDeclList($1, vd);
  }
  $$ = vds;
}

ARRAY_SPEC : '[' ']' {
  $$.value = 0;
} | '[' NUM ']' {
  $$ = $2;
}

EMPTY_OR_ARRAY_SPEC : {
  $$.value = -1;
} | ARRAY_SPEC {
  $$ = $1;
}

ARRAY_ELM : NUM {
  $$ = $1;
}

ARRAY_ELM_LIST : ARRAY_ELM {
  ArrayInitializer *array = new ArrayInitializer;
  array->num_.push_back($1.value);
  $$ = array;
} | ARRAY_ELM_LIST ',' ARRAY_ELM {
  $1->num_.push_back($3.value);
  $$ = $1;
}

ARRAY_INITIALIZER : '{' { ScannerInterface::InArrayElmDecl(); } ARRAY_ELM_LIST {ScannerInterface::EndArrayElmDecl(); } '}' {
  $$ = $3;
}

VAR_DECL_STMT : VAR_DECL {
  ScannerInterface::InSemiColonStatement();
  $$ = $1;
} | VAR_DECL K_ASSIGN EXPR {
  ScannerInterface::InSemiColonStatement();
  if ($1->decls.size() > 1) {
    yyerror("More than 1 LHS to initialize");
    YYABORT;
  }
  $1->decls[0]->SetInitialVal($3);
  $$ = Builder::VarDeclList(nullptr, $1->decls[0]);
} | VAR_DECL K_ASSIGN ARRAY_INITIALIZER {
  ScannerInterface::InSemiColonStatement();
  if ($1->decls.size() > 1) {
    yyerror("More than 1 LHS to initialize");
    YYABORT;
  }
  if ($1->decls[0]->GetArrayLength() < 0) {
    yyerror("Array initializer to non array");
    YYABORT;
  }
  Builder::SetArrayInitializer($1->decls[0], $3);
  $$ = Builder::VarDeclList(nullptr, $1->decls[0]);
}

TYPE_NAME : K_INT {
  $$ = sym_int;
} | K_BOOL {
  $$ = sym_bool;
} | K_OBJECT {
  $$ = sym_object;
} | K_STRING {
  $$ = sym_string;
}


LABEL : SYM ':' {
}

RETURN : K_RETURN {
  ScannerInterface::InSemiColonStatement();
}

STMT : EOS {
  /* empty stmt */
} | EXPR EOS {
  Emitter::EmitExprStmt($1);
} | ENUM_DECL EOS {
} | K_GOTO FUNCALL EOS {
} | K_GOTO SYM EOS {
} | RETURN EXPR EOS {
  Emitter::EmitReturnStmt($2);
} | RETURN EOS {
  Emitter::EmitReturnStmt(nullptr);
} | BLOCK {
} | IF_STMT {
} | FOR_STMT {
} | WHILE_STMT {
} | DO_WHILE_STMT {
} | SWITCH_STMT {
} | VAR_DECL_STMT EOS {
  Emitter::EmitVarDeclStmtSet($1);
} | LABEL
  | K_IMPORT {ScannerInterface::InSemiColonStatement();} STR EOS {
  Emitter::EmitImportStmt($3);
} | K_SPAWN {ScannerInterface::InSemiColonStatement();} FUNCALL EOS {
  Emitter::EmitSpawnStmt($3);
} | THREAD_DECL_STMT EOS {
} | CHANNEL_DECL_STMT EOS {
} | MAILBOX_DECL_STMT EOS {
}

// End Of Statement
EOS : ';' {
  ScannerInterface::EndSemiColonStatement();
}

THREAD_DECL_STMT : K_THREAD {ScannerInterface::InSemiColonStatement();} VAR K_ASSIGN FUNCALL {
  Emitter::EmitThreadDeclStmt($3, $5);
}

CHANNEL_DECL_STMT : K_CHANNEL {ScannerInterface::InSemiColonStatement();} VAR K_ASSIGN WIDTH_SPEC {
  Emitter::EmitChannelDeclStmt($3, $5.is_primitive, $5.name, $5.width);
}

MAILBOX_DECL_STMT : K_MAILBOX {ScannerInterface::InSemiColonStatement();} VAR K_ASSIGN WIDTH_SPEC {
  Emitter::EmitMailboxDeclStmt($3, $5.is_primitive, $5.name, $5.width);
}

IF_COND_PART : K_IF '(' EXPR ')' {
  $$ = Emitter::EmitIfStmt($3);
  Emitter::EmitLabel($$->label_t_);
}

IF_WITH_ELSE : IF_COND_PART BLOCK K_ELSE {
  $$ = $1;
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
}

IF_STMT : IF_COND_PART BLOCK {
  $$ = nullptr;
  Emitter::EmitLabel($1->label_f_);
  Emitter::EmitLabel($1->label_join_);
} | IF_WITH_ELSE BLOCK {
  $$ = nullptr;
  Emitter::EmitLabel($1->label_join_);
} | IF_WITH_ELSE IF_STMT {
  $$ = nullptr;
  Emitter::EmitLabel($1->label_join_);
}

FOR_HEAD : K_FOR '(' EXPR ';' {
  Emitter::BeginBlock();
  Emitter::EmitExprStmt($3);
}

FOR_COND_PART : FOR_HEAD EXPR {
  $$ = Emitter::EmitForStmt($2);
  Emitter::EmitLabel($$->label_t_);
}

FOR_STMT : FOR_COND_PART ';' EXPR ')' BLOCK {
  // join:
  // cond_expr
  // if (cond_expr)
  //  t:
  //  block
  //  repeat_expr
  // goto join:
  //  f:
  Emitter::EmitExprStmt($3);
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
  Emitter::EndBlock();
}

WHILE_COND_PART : K_WHILE '(' EXPR ')' {
  Emitter::BeginBlock();
  // Emit a dummy insn before label_join so that compiler can
  // find a insn after the label.
  Emitter::EmitNop();
  $$ = Emitter::EmitWhileStmt($3);
  Emitter::EmitLabel($$->label_t_);
}

WHILE_STMT : WHILE_COND_PART BLOCK {
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
  Emitter::EndBlock();
}

DO_WHILE_HEAD : K_DO {
  Emitter::BeginBlock();
  Emitter::EmitNop();
  $$ = Builder::DoWhileStmt();
  Emitter::EmitLabel($$->label_join_);
}

DO_WHILE_BODY : DO_WHILE_HEAD BLOCK {
  $$ = $1;
}

DO_WHILE_STMT : DO_WHILE_BODY K_WHILE '(' EXPR ')' {
  Emitter::EmitDoWhileStmt($1, $4);
  Emitter::EmitLabel($1->label_t_);
  Emitter::EmitGoto($1->label_join_);
  Emitter::EmitLabel($1->label_f_);
  Emitter::EndBlock();
}

SWITCH_STMT : K_SWITCH '(' EXPR ')' CASES_LIST {
}

CASES_LIST : CASE {
} | CASES_LIST CASE {
}

CASE : K_DEFAULT {
}

BLOCK : BLOCK_HEAD STMT_LIST '}' {
  Emitter::EndBlock();
}

BLOCK_HEAD : '{' {
  /* open new bindings */
  Emitter::BeginBlock();
}

ENUM_DECL : K_ENUM VAR '{' ENUM_ITEM_LIST '}' {
  Emitter::EmitEnumTypeDeclStmt($2, $4);
}

ENUM_ITEM_LIST : SYM {
  $$ = Builder::EnumItemList(nullptr, $1);
} | ENUM_ITEM_LIST ',' SYM {
  $$ = Builder::EnumItemList($1, $3);
}

EXPR : SYM {
  ScannerInterface::InSemiColonStatement();
  $$ = Builder::SymExpr($1);
} | '(' EXPR ')' {
  $$ = $2;
} | EXPR '[' EXPR ']' {
  $$ = Builder::ArrayRefExpr($1, $3);
} | EXPR '[' EXPR ':' EXPR ']' {
  $$ = Builder::BitRangeRefExpr($1, $3, $5);
} | EXPR ',' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_COMMA);
} | EXPR '.' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_ELM_REF);
} | FUNCALL {
  $$ = $1;
} | '!' EXPR {
  $$ = Builder::LogicInvertExpr($2);
} | '~' EXPR {
  $$ = Builder::BitInvertExpr($2);
} | '*' EXPR {
  $$ = Builder::RefExpr($2);
} | EXPR K_ADD_SUB EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR '*' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_MUL);
} | EXPR K_SHIFT EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_ASSIGN EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_LG_COMPARE EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_EQ_COMPARE EXPR {
  $$ = Builder::BinopExpr($1, $3, $2);
} | EXPR K_BIT_CONCAT EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_CONCAT);
} | EXPR '&' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_AND);
} | EXPR '|' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_OR);
} | EXPR '^' EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_XOR);
} | EXPR K_LOGIC_OR EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_LOR);
} | EXPR K_LOGIC_AND EXPR {
  $$ = Builder::BinopExpr($1, $3, BINOP_LAND);
} | EXPR K_INC_DEC {
  $$ = Builder::IncDecExpr($1, $2, true);
} | K_INC_DEC EXPR {
  $$ = Builder::IncDecExpr($2, $1, false);
} | K_ADD_SUB EXPR %prec SIGN {
  $$ = Builder::SignedExpr($1, $2);
} | EXPR '?' EXPR ':' EXPR {
  $$ = Builder::TriTerm($1, $3, $5);
} | STR {
  ScannerInterface::InSemiColonStatement();
  $$ = Builder::StrExpr($1);
} | NUM {
  ScannerInterface::InSemiColonStatement();
  $$ = Builder::NumExpr($1.value);
}

VAR : SYM {
  $$ = Builder::SymExpr($1);
} | VAR '.' SYM {
  $$ = Builder::ElmSymRefExpr($1, $3);
}

VAR_LIST : VAR {
  $$ = Builder::ExprList(nullptr, $1);
} | VAR_LIST ',' VAR {
  $$ = Builder::ExprList($1, $3);
}

FUNCALL_HEAD : SYM '(' {
  $$ = Builder::SymExpr($1);
}

FUNCALL :  FUNCALL_HEAD ARG_LIST ')' {
  ScannerInterface::InSemiColonStatement();
  $$ = Builder::FuncallExpr($1, $2);
}

ARG_LIST : {
  $$ = nullptr;
} | EXPR {
  $$ = $1;
}

%%
